<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="settings.xml">
<entry key="node_file" type="xstring" value="settings.xml"/>
<config key="flow_stack"/>
<config key="internal_node_subsettings">
<entry key="memory_policy" type="xstring" value="CacheSmallInMemory"/>
</config>
<config key="model">
<entry key="sourceCode" type="xstring" value="%%00010import pandas as pd%%00010import numpy as np%%00010from scipy.optimize import root%%00010%%00010# define key variables for model%%00010# -----------------------------------%%00010TCRE_val = 1.4%%00010TCR_val = 1.6%%00010ECS_val = 2.75%%00010in_state_vals = [[76., 58., 24., 5.], [0.12, 0.92], 500.]%%00010# -----------------------------------%%00010%%00010# find annual emissions to run through FaIR%%00010co2_equiv_emissions = pd.DataFrame(input_table_1)%%00010co2_equiv_emissions.Years = co2_equiv_emissions.Years.astype('float64')%%00010global_annual_ems = co2_equiv_emissions['world_annual_ems[GtC/yr]'].values%%00010global_cum_ems = co2_equiv_emissions['world_cum_ems[GtC]'].values%%00010%%00010# define the carbon only simple climate model to run emissions through to find temperature response%%00010# -----------------------------------%%00010%%00010# Define a function which gives the relationship between iIRF_100 and scaling factor, alpha%%00010def iirf100_interp_funct_insitu(alpha,a,tau,targ_iirf100):%%00010    iirf100_arr = alpha*(np.sum(a*tau*(1.0 - np.exp(-100.0/(tau*alpha)))))%%00010    return iirf100_arr   -  targ_iirf100%%00010%%00010# Define the FAIR simple climate model function (v1.0)%%00010def fair_scm_insitu(tstep=1.0,%%00010             emissions=False,%%00010             other_rf=0.0,%%00010             tcrecs=np.array([1.6,2.75]),%%00010             d=np.array([239.0,4.1]),%%00010             a=np.array([0.2173,0.2240,0.2824,0.2763]),%%00010             tau=np.array([1000000,394.4,36.54,4.304]),%%00010             r0=32.40,%%00010             rC=0.019,%%00010             rT=4.165,%%00010             F_2x=3.74,%%00010             C_0=278.0,%%00010             ppm_gtc=2.123,%%00010             iirf100_max=97.0,%%00010             in_state=[[0.0,0.0,0.0,0.0],[0.0,0.0],0.0]):%%00010%%00010    # # # ------------ CALCULATE Q ARRAY ------------ # # #%%00010    # If TCR and ECS are supplied, overwrite the q array%%00010    k = 1.0 - (d/70.0)*(1.0 - np.exp(-70.0/d))%%00010    q =  (1.0 / F_2x) * (1.0/(k[0]-k[1])) * np.array([tcrecs[0]-k[1]*tcrecs[1],k[0]*tcrecs[1]-tcrecs[0]])%%00010%%00010    # # # ------------ SET UP OUTPUT TIMESERIES VARIABLES ------------ # # #%%00010    # the integ_len variable is used to store the length of our timeseries%%00010    # by default FAIR is not concentration driven%%00010    conc_driven=False%%00010    # here we check if FAIR is emissions driven%%00010    if type(emissions) in [np.ndarray,list]:%%00010        integ_len = len(emissions)%%00010        if (type(other_rf) in [np.ndarray,list]) and (len(other_rf)!=integ_len):%%00010            raise ValueError(&quot;The emissions and other_rf timeseries don't have the same length&quot;)%%00010        elif type(other_rf) in [int,float]:%%00010            other_rf = np.full(integ_len,other_rf)%%00010  %%00010    RF = np.zeros(integ_len)%%00010    C_acc = np.zeros(integ_len)%%00010    iirf100 = np.zeros(integ_len)%%00010%%00010    carbon_boxes_shape = (integ_len,4)%%00010    R_i = np.zeros(carbon_boxes_shape)%%00010    C = np.zeros(integ_len)%%00010%%00010    thermal_boxes_shape = (integ_len,2)%%00010    T_j = np.zeros(thermal_boxes_shape)%%00010    T = np.zeros(integ_len)%%00010%%00010    # # # ------------ FIRST TIMESTEP ------------ # # #%%00010    R_i_pre = in_state[0]%%00010    C_pre = np.sum(R_i_pre) + C_0%%00010    T_j_pre = in_state[1]%%00010    C_acc_pre = in_state[2]%%00010  %%00010    # Calculate the parametrised iIRF and check if it is over the maximum %%00010    # allowed value%%00010    iirf100[0] = r0 + rC*C_acc_pre + rT*np.sum(T_j_pre)%%00010    if iirf100[0] &gt;= iirf100_max:%%00010        iirf100[0] = iirf100_max%%00010%%00010    # Determine a solution for alpha using scipy's root finder%%00010    time_scale_sf = (root(iirf100_interp_funct_insitu,0.16,args=(a,tau,iirf100[0]),method='hybr'))['x']%%00010%%00010    # Multiply default timescales by scale factor%%00010    tau_new = time_scale_sf * tau%%00010%%00010    # Compute the updated concentrations box anomalies from the decay of the %%00010    # previous year and the emisisons%%00010    R_i[0] = R_i_pre*np.exp(-tstep/tau_new) + (emissions[0,np.newaxis])*a*tau_new*(1-np.exp(-tstep/tau_new)) / ppm_gtc%%00010%%00010    C[0] = np.sum(R_i[0]) + C_0%%00010%%00010    # Calculate the additional carbon uptake%%00010    C_acc[0] =  C_acc_pre + emissions[0] - (C[0]-(np.sum(R_i_pre) + C_0)) * ppm_gtc%%00010%%00010    # Calculate the radiative forcing using the previous timestep's CO2 concentration%%00010    RF[0] = (F_2x/np.log(2.)) * np.log(C_pre/C_0) + other_rf[0]%%00010%%00010    # Update the thermal response boxes%%00010    T_j[0] = RF[0,np.newaxis]*q*(1-np.exp((-tstep)/d)) + T_j_pre*np.exp(-tstep/d)%%00010%%00010    # Sum the thermal response boxes to get the total temperature anomlay%%00010    T[0] = np.sum(T_j[0])%%00010%%00010    # # # ------------ REST OF RUN ------------ # # #%%00010    for x in range(1,integ_len):%%00010        # Calculate the parametrised iIRF and check if it is over the maximum %%00010        # allowed value%%00010        iirf100[x] = r0 + rC*C_acc[x-1] + rT*T[x-1]%%00010        if iirf100[x] &gt;= iirf100_max:%%00010            iirf100[x] = iirf100_max%%00010%%00010        # Determine a solution for alpha using scipy's root finder%%00010        time_scale_sf = (root(iirf100_interp_funct_insitu,time_scale_sf,args=(a,tau,iirf100[x])))['x']%%00010%%00010        # Multiply default timescales by scale factor%%00010        tau_new = time_scale_sf * tau%%00010%%00010        # Compute the updated concentrations box anomalies from the decay of the previous year and the emisisons%%00010        R_i[x] = R_i[x-1]*np.exp(-tstep/tau_new) + (emissions[x,np.newaxis])*a*tau_new*(1-np.exp(-tstep/tau_new)) / ppm_gtc%%00010%%00010#         R_i[x] = R_i[x-1]*np.exp(-tstep/tau_new) + (emissions[x,np.newaxis])*a / ppm_gtc%%00010%%00010        # Sum the boxes to get the total concentration anomaly%%00010        C[x] = np.sum(R_i[x]) + C_0%%00010%%00010        # Calculate the additional carbon uptake%%00010        C_acc[x] =  C_acc[x-1] + emissions[x] * tstep - (C[x]-C[x-1]) * ppm_gtc%%00010%%00010        # Calculate the radiative forcing using the previous timestep's CO2 concentration%%00010        RF[x] = (F_2x/np.log(2.)) * np.log((C[x-1]) /C_0) + other_rf[x]%%00010%%00010        # Update the thermal response boxes%%00010        T_j[x] = T_j[x-1]*np.exp(-tstep/d) + RF[x,np.newaxis]*q*(1-np.exp(-tstep/d))%%00010%%00010        # Sum the thermal response boxes to get the total temperature anomaly%%00010        T[x] = np.sum(T_j[x])%%00010%%00010    return T%%00010#%%00009return C, T, RF, R_i, T_j, C_acc%%00010# -----------------------------------%%00010%%00010# calculate cumulative emissions and temperature response%%00010# -----------------------------------%%00010T_fair = fair_scm_insitu(emissions = global_annual_ems[2018-1990:], in_state=in_state_vals, tcrecs=np.array([TCR_val,ECS_val])) %%00010%%00010#T_TCRE = 1.04 + (TCRE_val * (global_cum_ems[2018-1990:2101-1990] - global_cum_ems[2018-1990]) / 1000.)%%00010T_TCRE = 1.04 + TCRE_val*(global_cum_ems[2018-1990:2101-1990] - global_cum_ems[2017-1990])/1000.%%00010%%00010T_TCRE_relToPreInd = 1.14 + TCRE_val*(global_cum_ems[2018-1990:2101-1990] - global_cum_ems[2018-1990])/1000.%%00010%%00010# -----------------------------------%%00010%%00010# stitch on historical temps in the past%%00010awi_historical = pd.DataFrame(input_table_2)%%00010awi_historical['Years'] = pd.to_numeric(awi_historical['Years'],downcast='integer')%%00010awi_historical = awi_historical.set_index('Years')%%00010%%00010total_temp_array = np.zeros(2101-1850)%%00010total_temp_array[0:2018-1850] = awi_historical.loc[1850:2018].T.values[0]%%00010total_temp_array[2018-1850:2101-1850] = T_TCRE%%00010%%00010total_temp_array_relpreind = total_temp_array + 0.1%%00010%%00010total_temp_array_SCM = np.copy(total_temp_array)%%00010total_temp_array_SCM[2018-1850:] = T_fair%%00010%%00010## create a column containing the emissions in Mt CO2e%%00010co2e_world_annual = co2_equiv_emissions['world_annual_ems[GtC/yr]'].values * 44000. / 12.%%00010%%00010## create a column containing the cumulative emissions in Mt CO2e%%00010co2e_world_cum = co2_equiv_emissions['world_cum_ems[GtC]'].values * 44000. / 12.%%00010%%00010## crate a column containing the cumulative emissions in Mt CO2e relative to pre-industrial%%00010co2e_world_cum_relPreind = ((co2_equiv_emissions['world_cum_ems[GtC]'].values * 44. / 12.) - (co2_equiv_emissions['world_cum_ems[GtC]'].values[2015-1990] * 44. / 12.) + 2900. + 260.) * 1000.%%00010%%00010## create a column containing the RoW emissions in Mt CO2e%%00010co2e_RoW_annual = co2_equiv_emissions['RoW_ems_annual[GtC/yr]'].values * 44000. / 12.%%00010%%00010## create a column containing the RoW cumulative emissions in Mt CO2e%%00010co2e_RoW_cum = co2_equiv_emissions['RoW_ems_cum[GtC]'].values * 44000. / 12.%%00010%%00010#output_table = pd.DataFrame([np.arange(1990,2101),co2_equiv_emissions['EU_annual_ems[GtC/yr]'].values,co2_equiv_emissions['EU_cum_ems[GtC]'].values,co2_equiv_emissions['RoW_annual_ems[GtC/yr]'].values,co2_equiv_emissions['RoW_cum_ems[GtC]'].values,co2_equiv_emissions['world_annual_ems[GtC/yr]'].values,co2_equiv_emissions['world_cum_ems[GtC]'].values,np.arange(2018,2101),T_fair,T_TCRE,T_TCRE_relToPreInd]).T%%00010output_table = pd.DataFrame([np.arange(1990,2101),co2_equiv_emissions['clm_ems_annual_EU[GtC/yr]'].values,co2_equiv_emissions['clm_ems_cumulative_EU[GtC]'].values,co2_equiv_emissions['RoW_ems_annual[GtC/yr]'].values,co2_equiv_emissions['RoW_ems_cum[GtC]'].values,co2_equiv_emissions['world_annual_ems[GtC/yr]'].values,co2_equiv_emissions['world_cum_ems[GtC]'].values, co2e_world_annual, total_temp_array[1990-1850:],total_temp_array_relpreind[1990-1850:], total_temp_array_SCM[1990-1850:], co2e_world_cum_relPreind, co2_equiv_emissions['clm_cum_emissions-CO2e_EU[Gt]'].values, co2_equiv_emissions['clm_emissions-CO2e_EU[Gt]'].values, co2e_RoW_annual, co2e_world_cum, co2e_RoW_cum]).T%%00010output_table.columns = ['Years','EU_annual_ems[GtC/yr]','EU_cum_ems[GtC]','RoW_annual_ems[GtC/yr]','RoW_cum_ems[GtC]','worldtotal_annual_ems[GtC/yr]','worldtotal_cum_ems[GtC]', 'clt_emissions-CO2e[Mt]','TCRE_Temp[Krelto1850-1900]','TCRE_Temp[Krelto1720-1800]','SCM_Temp[Krelto1850-1900]', 'worldtotal_cum_ems[MtCO2eReltoPreIndust]', 'clm_cum_emissions-CO2e_EU[Gt]', 'clm_emissions-CO2e_EU[Gt]', 'clm_emissions-CO2e_RoW[Mt]', 'worldtotal_cum_ems[MtCO2e]', 'clm_cum_emissions-CO2e_RoW[Mt]']%%00010output_table['Years'] = pd.to_numeric(output_table['Years'],downcast='integer')%%00010output_table['Years'] = output_table['Years'].astype(str)"/>
<entry key="rowLimit" type="xint" value="1000"/>
<entry key="pythonVersionOption" type="xstring" value="PYTHON3"/>
<entry key="convertMissingToPython" type="xboolean" value="false"/>
<entry key="convertMissingFromPython" type="xboolean" value="false"/>
<entry key="sentinelOption" type="xstring" value="MIN_VAL"/>
<entry key="sentinelValue" type="xint" value="0"/>
<entry key="chunkSize" type="xint" value="500000"/>
<entry key="python2Command" type="xstring" value=""/>
<entry key="python3Command" type="xstring" value=""/>
</config>
<config key="nodeAnnotation">
<entry key="text" type="xstring" value="Calculate temperature %%00010response to %%00010global emissions input"/>
<entry key="bgcolor" type="xint" value="16777215"/>
<entry key="x-coordinate" type="xint" value="4104"/>
<entry key="y-coordinate" type="xint" value="721"/>
<entry key="width" type="xint" value="112"/>
<entry key="height" type="xint" value="36"/>
<entry key="alignment" type="xstring" value="CENTER"/>
<entry key="borderSize" type="xint" value="0"/>
<entry key="borderColor" type="xint" value="16777215"/>
<entry key="defFontSize" type="xint" value="11"/>
<entry key="annotation-version" type="xint" value="20151123"/>
<config key="styles"/>
</config>
<entry key="customDescription" type="xstring" isnull="true" value=""/>
<entry key="state" type="xstring" value="EXECUTED"/>
<entry key="factory" type="xstring" value="org.knime.python2.nodes.script2in1out.Python2Script2In1OutNodeFactory"/>
<entry key="node-name" type="xstring" value="Python Script (2⇒1)"/>
<entry key="node-bundle-name" type="xstring" value="KNIME Python nodes"/>
<entry key="node-bundle-symbolic-name" type="xstring" value="org.knime.python2.nodes"/>
<entry key="node-bundle-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
<entry key="node-bundle-version" type="xstring" value="3.7.2.v201904170931"/>
<entry key="node-feature-name" type="xstring" value="KNIME Python Integration"/>
<entry key="node-feature-symbolic-name" type="xstring" value="org.knime.features.python2.feature.group"/>
<entry key="node-feature-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
<entry key="node-feature-version" type="xstring" value="3.7.2.v201904170931"/>
<config key="factory_settings"/>
<entry key="name" type="xstring" value="Python Script (2⇒1)"/>
<entry key="hasContent" type="xboolean" value="true"/>
<entry key="isInactive" type="xboolean" value="false"/>
<config key="ports">
<config key="port_1">
<entry key="index" type="xint" value="1"/>
<entry key="port_spec_class" type="xstring" value="org.knime.core.data.DataTableSpec"/>
<entry key="port_object_class" type="xstring" value="org.knime.core.node.BufferedDataTable"/>
<entry key="port_object_summary" type="xstring" value="Rows: 111, Cols: 17"/>
<entry key="port_dir_location" type="xstring" value="port_1"/>
</config>
</config>
<config key="filestores">
<entry key="file_store_location" type="xstring" isnull="true" value=""/>
<entry key="file_store_id" type="xstring" value="a04c1bc1-09cb-4bfa-ac56-b18b4eeee2bc"/>
</config>
</config>
